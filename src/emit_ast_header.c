/**
 * @file emit_ast_header.c
 *
 * @brief This is a AST traverse pass that emits the AST source code and the
 * AST header file. This relies on the command line features to retrieve the
 * configuration.
 *
 * @author Chuck Tilbury (chucktilbury@gmail.com)
 * @version 0.0
 * @date 2024-08-07
 * @copyright Copyright (c) 2024
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <time.h>

#include "emit.h"
#include "ast.h"
#include "str.h"
#include "str_lst.h"
#include "cmdline.h"

static const char* preamble[] = {
    " */",
    "#ifndef _EMIT_AST_HEADER_H_",
    "#define _EMIT_AST_HEADER_H_",
    "",
    "#include \"ptr_lst.h\"",
    "#include \"str.h\"",
    "",
    "void traverse_ast(AstPassFunc pre, AstPassFunc post);",
    "AstNode* create_ast_node(AstNodeType type);",
    "",
    "typedef struct _ast_node_ {",
    "    AstNodeType type;",
    "} AstNode;",
    "",
    NULL
};

static const char* postamble[] = {
    "",
    "#endif /* _EMIT_AST_HEADER_H_ */"
    "",
    "/*",
    " * End of generated file.",
    " */",
    "",
    NULL
};

/*
 * These are the lists that were generated when the parser ran.
 */
extern StrLst* terms;
extern StrLst* nterms;

// output file handle for the ast header file that is generated by this module.
static FILE* outfile = NULL;


static int _error(const char* fn, int state) {
    fprintf(stderr, "Fatal internal error: invalid state in %s: %d\n", fn, state);
    abort();
}

static int dummy(void) {
    // do nothing.
    return 0;
}

static int pre_ds_rule(AstNode* node) {

    fprintf(outfile, "typedef struct _ast_%s_ {\n    AstNode type;\n", 
            raw_string(((ast_rule_t*)node)->name));

    return 0;
}

static int post_ds_rule(AstNode* node) {

    fprintf(outfile, "} ast_%s_t;\n\n", 
            raw_string(((ast_rule_t*)node)->name));

    return 0;
}

static int ast_ds_pre_nterm(AstNode* node) {

    const char* str = raw_string(((ast_nterm_reference_t*)node)->tok);
    fprintf(outfile, "    struct _ast_%s_* %s;\n", str, str);

    return 0;
}

static int ast_ds_pre_term(AstNode* node) {

    String* str = ((ast_terminal_t*)node)->tok;
    String* tmp = copy_string(str);
    lower_string(tmp);
    const char* tstr = raw_string(tmp);

    if(tstr[0] == 's')
        fprintf(outfile, "    TokenType %s_type;\n", &tstr[4]);
    destroy_string(tmp);

    return 0;
}

static int ast_ds_pre(AstNode* node) {

    return (node->type == AST_TERMINAL)         ? ast_ds_pre_term(node) :
            (node->type == AST_NTERM_REFERENCE) ? ast_ds_pre_nterm(node) :
            (node->type == AST_ZERO_OR_ONE)     ? dummy() :
            (node->type == AST_ONE_OR_MORE)     ? dummy() :
            (node->type == AST_ZERO_OR_MORE)    ? dummy() :
            (node->type == AST_GROUP)           ? dummy() :
            (node->type == AST_GRAMMAR)         ? dummy() :
            (node->type == AST_RULE)            ? pre_ds_rule(node) :
            (node->type == AST_PRODUCTION_LIST) ? dummy() :
            (node->type == AST_PRODUCTION)      ? dummy() :
            (node->type == AST_PROD_ELEM)       ? dummy() :
                                                  _error(__func__, node->type);
}

static int ast_ds_post(AstNode* node) {

    return (node->type == AST_TERMINAL)         ? dummy() :
            (node->type == AST_NTERM_REFERENCE) ? dummy() :
            (node->type == AST_ZERO_OR_ONE)     ? dummy() :
            (node->type == AST_ONE_OR_MORE)     ? dummy() :
            (node->type == AST_ZERO_OR_MORE)    ? dummy() :
            (node->type == AST_GROUP)           ? dummy() :
            (node->type == AST_GRAMMAR)         ? dummy() :
            (node->type == AST_RULE)            ? post_ds_rule(node) :
            (node->type == AST_PRODUCTION_LIST) ? dummy() :
            (node->type == AST_PRODUCTION)      ? dummy() :
            (node->type == AST_PROD_ELEM)       ? dummy() :
                                                  _error(__func__, node->type);
}

static void emit_ds(void) {

    traverse_ast(ast_ds_pre, ast_ds_post);
}

static void emit_protos(void) {

    int mark = 0;
    String* str;

    while(NULL != (str = iterate_str_lst(nterms, &mark))) {
        const char* tpt = raw_string(str);
        fprintf(outfile, "void ast_%s(ast_%s_t* node, AstPassFunc pre, AstPassFunc post);\n",
            tpt, tpt);
    }
}

void emit_type_list(void) {

    int mark = 0;
    String* str;

    fprintf(outfile, "typedef enum {\n");

    while(NULL != (str = iterate_str_lst(nterms, &mark))) {
        String* cpy_ptr = copy_string(str);
        upper_string(cpy_ptr);
        fprintf(outfile, "    AST_%s,\n", raw_string(cpy_ptr));
        destroy_string(cpy_ptr);
    }

    fprintf(outfile, "} AstNodeType;\n\n");
}

void emit_ast_header(void) {

    String* str = create_string(get_cmdline("ast_name"));
    append_string_str(str, ".h");

    outfile = fopen(raw_string(str), "w");
    if(outfile == NULL) {
        fprintf(stderr, "Fatal error: cannot open output file: '%s': %s\n",
                raw_string(str), strerror(errno));
        exit(1);
    }
    clear_string(str);

    time_t t = time(NULL);

    fprintf(outfile, "/*\n");
    fprintf(outfile, " * File generated on %s.\n", ctime(&t));
    emit_block(outfile, preamble);

    emit_type_list();

    emit_ds();
    emit_protos();

    emit_block(outfile, postamble);
    destroy_string(str);
}

